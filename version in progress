import os
from alpaca.data import StockHistoricalDataClient
from alpaca.data.requests import StockBarsRequest
from alpaca.data.timeframe import TimeFrame
from datetime import datetime
import pandas as pd

#Make summary of all functions + inputs and what they return, as documentation for strategy coding

#For future use --- row.name returns index of row
#for simplicity, all profit calculated is FIFO-based
#Evaluate strengths and weaknesses of FIFO-based calculation, and put in README file (or separate text-based file)

apiKey = os.getenv("AlpacaKey")
apiSecret = os.getenv("AlpacaSecret")
stock_client = StockHistoricalDataClient(apiKey, apiSecret)

def getData(stock, startDateTime, endDateTime,interval=TimeFrame.Minute):
    dataParams = StockBarsRequest(symbol_or_symbols=stock,
                                            timeframe=interval, 
                                            start=startDateTime,
                                              end=endDateTime)
    barsData = stock_client.get_stock_bars(dataParams) #For some reason the Alpaca Documentation is slightly weird i cant directly pluck the parameters into the .get_stock_bars function, it only accepts one argument
    return barsData.df.reset_index()

startDate =  datetime(2023,1,4)
endDate = datetime(2023,1,5)
timePeriod = (endDate-startDate).days*390 #390 trading minutes per trading day
data = getData(["AAPL","NVDA"], startDate, endDate)
portfolioAtThisTrade = {stock: [] for stock in data["symbol"].unique()}
capitalInMarketAtThisTrade = {stock:[] for stock in data["symbol"].unique()} #Think: is it correct to say that capital in market for a stock X at time Y is = (total portfolio value of X - paper P/L of X at time Y) or simply = value of stock Xs in purchaseDict that have yet to be sold
def buyStock(row, qty, price): #Note: dont update trade og dictionary using merely timestamp as key because if diff types of stocks purchased at sqame time then new value will override
    global purchaseDict, currentCash, buyCount, stockQTY, salesDict
    if qty*price > currentCash:
        qty = int(currentCash/price) #Buys as many stocks as possible if full order cannot be fufilled
    if qty != 0:
        key = "%s%s"%(row["symbol"],row.name)
        purchaseDict[key] = [str(row["symbol"]), row, qty, price]
        currentCash -= qty*price
        buyCount +=1
        stockQTY[row["symbol"]] = stockQTY.get(row["symbol"],0) + qty
        portfolioAtThisTrade[row["symbol"]].append(stockQTY.get(row["symbol"]))
        _, capitalIn = calculatePaperProfit(purchaseDict, salesDict, row, stockQTY)
        capitalInMarketAtThisTrade[row["symbol"]].append(capitalIn)
    else:
        pass

def calculatePaperProfit(purchaseDict, salesDict, row, stockQTY): #Also FIFO-based. THis only deals with one specific type of stock, specified in row
    stockOfInterest = row["symbol"]
    nStockLeft = stockQTY.get(stockOfInterest)
    if nStockLeft == 0:
        return 0
    else:
        stripPurchaseDict = {}#This is only for ONE TYPE of stock! Structure: Key1:Value1 = quantity of stock in first purchase, value of stock at first purchase --- this allows for easy calculation of capital poured into current holdings
        uniqueID = 0#keys wont overlap if same qty purchased
        for key, value in purchaseDict.items():
            purchaseID = "%d|%s"%(uniqueID, value[2]) #The delimeter in the middle is so that value can be separated from ID easily in the future when called
            stripPurchaseDict = {purchaseID:value[3], **stripPurchaseDict} #Note for future: this inserts the key-value pair at front of dict. double asterisk is to unpack the iterable --- dict gets unpacked into all key-value pairs
            #cost is PER STOCK, not total! FIFO-based operation thus stocks held will be latest stocks purchased (and so dict must be reversed)
    principalSumOfCurrentHolding = 0
    for key, value in stripPurchaseDict.items():
        _, qty = key.split("|")
        if nStockLeft == 0:
            break
        if qty <= nStockLeft:
            principalSumOfCurrentHolding += qty*value
            nStockLeft -= qty
        else:
            qty = nStockLeft
            principalSumOfCurrentHolding += qty*value
            nStockLeft = 0
    valueOfCurrentHolding = stockQTY.get(stockOfInterest)*((row["open"]+row["close"])/2)
    paperProfit = valueOfCurrentHolding-principalSumOfCurrentHolding
    return paperProfit, principalSumOfCurrentHolding
            
            
def calculateFIFOProfit(purchaseDict, salesDict, row, qty, sell_price):
    global W,L, BE
    symbol = row["symbol"]
    purchases = []
    for key, value in sorted(purchaseDict.items()):
            if value[0] == symbol:
                purchases.append({
                    'timestamp': key,
                    'qty': value[2],
                    'price': value[3]
                })
    
    total_sold_before = 0
    for key, value in salesDict.items():
        if value[0] == symbol:
            total_sold_before += value[2]

    shares_to_cost = qty  # How many shares to sell in this round of sale
    fifo_cost = 0
    shares_processed = 0
    
    for purchase in purchases:
        if shares_to_cost <= 0:
            break
            
        purchase_qty = purchase['qty']
        purchase_price = purchase['price']
        
        if shares_processed + purchase_qty <= total_sold_before:
            shares_processed += purchase_qty
            continue
        
        already_used = max(0, total_sold_before - shares_processed)
        available_shares = purchase_qty - already_used
        shares_to_use = min(available_shares, shares_to_cost)
        
        fifo_cost += shares_to_use * purchase_price
        shares_to_cost -= shares_to_use
        shares_processed += purchase_qty
        if purchase_price > sell_price:
            for i in range(0, shares_to_use):
                L.append(symbol)
        elif sell_price > purchase_price:
            for i in range(0, shares_to_use):
                W.append(symbol)
        else:
            for i in range(0, shares_to_use):
                BE.append(symbol) #gotta use append structure so that can track which stock wins, instead of just using a counter to see how many stocks win
    
    profit = (qty * sell_price) - fifo_cost
    
    return profit

def sellStock(row, qty, price):
    global purchaseDict, salesDict, currentCash, sellCount, stockQTY
    if stockQTY.get(row["symbol"]) < qty:
        qty = stockQTY.get(row["symbol"])
    if qty != 0:
        key = "%s%s"%(row["symbol"],row.name)
        profit = calculateFIFOProfit(purchaseDict, salesDict, row, qty, price)
        currentCash += qty*price
        sellCount += 1
        salesDict[key] = [str(row["symbol"]), row, qty, price, profit]
        stockQTY[row["symbol"]] = stockQTY.get(row["symbol"]) - qty
        portfolioAtThisTrade[row["symbol"]].append(stockQTY.get(row["symbol"])
        _, capitalIn = calculatePaperProfit(purchaseDict, salesDict, row, stockQTY)
        capitalInMarketAtThisTrade[row["symbol"]].append(capitalIn)

def calculateAvgPrc(purchaseDict):
    stocksList = sorted(data["symbol"].unique())
    avgPriceDict = {}
    reversedDict = dict(reversed(list(purchaseDict.items())))
    for stock in stocksList:
        totalCost = 0
        stockCount = stockQTY.get(stock)
        for key, value in reversedDict.items():
            if value[0] != stock:
                continue
            else:
                if stockCount > value[2]:
                    totalCost += value[3]*value[2]
                    stockCount -= value[2]
                else:
                    totalCost += value[3]*stockCount
                    stockCount = 0
                    break
        try:
            avgCost = totalCost/stockQTY.get(stock)
        except:
            avgCost = 0
        avgPriceDict[stock] = avgCost
    return avgPriceDict
                    
    
def strategy(startCash, currentCash, dataRow, currentPositions):
   
    global stockQTY
    #Simplified Strat:
    currentStock = dataRow["symbol"]
    if stockQTY.get(currentStock) == 0:
        buyStock(dataRow, 5, dataRow["open"])

def calculateAlpha(data, stock, netProfitStock, startCash): 
    definedCapital = max(value for key, value in capitalInMarketAtThisTrade.items() if key == stock)
    noTradeGain = (filteredData.head(1).iloc[0]["open"] - filteredData.tail(1).iloc[0]["close"])*(definedCapital/filteredData.head(1).iloc[0]["open"]) #for future use of this value do note that there exists a possibility of this being negative
    alphaRaw = netProfitStock - noTradeGain #alpha will likely be negative if only a small percentage of capital is used to trade
    alphaPct =
    #alpharaw is the dollar value of how much algorithm has beat the market by, in USD
    #alphaPct, on the other hand, is the percentage which the algo has beaten the market by. This is in percentage points --- ie if market profits 8% and algo profits 10%, alphaPct = 2%, not 20%.
    
    


def tradeAnalyser(data, startCash, purchaseDict, salesDict, currentCash, stockQTY):
    global timePeriod
    nCandles = timePeriod
    analysisAvailable = {stock : None for stock in data["symbol"].unique()}
    for stock in data["symbol"].unique(): #DONT FORGET THAT THIS IS FOR EACH STOCK!!! These values must be stored before they are overwritten by next iteration of for loop
        if sum(1 for key, value in purchaseDict.items() if value[0] == stock) == 0:
            analysisAvailable[stock] = False
            continue
        analysisAvailable[stock] = True
        netProfit = sum(value[4] for key, value in salesDict.items() if value[0] == stock)
        dollarVolume = sum(value[3]*value[2] for key, value in purchaseDict.items() if value[0] == stock)
        revenue = sum(value[3]*value[2] for key, value in salesDict.items() if value[0] == stock)
        print(revenue-dollarVolume == netProfit) #This does indeed retunr true
        salesFrequency = sum(1 for key, value in salesDict.items() if value[0] == stock)/timePeriod
        purchaseFrequency = sum(1 for key, value in purchaseDict.items() if value[0] == stock)/timePeriod
        winRate_sales = (len([value for key, value in salesDict.items() if value[4] > 0 and value[0] == stock])/sum(1 for key, value in salesDict.items() if value[0] == stock))*100
        winRate_perStock = (W.count(stock)/(W.count(stock)+L.count(stock)+BE.count(stock)))*100
        maxStock = max(portfolioAtThisTrade.get(stock))
        #largest holding value --- this does not equate to definition of "trade capital" in alpha function above
        
        alphaPercent, alphaRaw, noTradeGain = calculateAlpha(data, stock, netProfit, startCash)
        #averageHoldingTime --- from this can calculate average number of stocks held in portfolio over the whole trading period


                
def engineRun(data, startCash = 100000):
    global purchaseDict, salesDict, currentCash, buyCount, sellCount, winningTradeCount, stockQTY, W, L, BE
    currentCash = startCash
    W = []
    L = []
    BE = []
    buyCount = 0
    sellCount = 0
    winningTradeCount = 0
    stockQTY = {stock: 0 for stock in data["symbol"].unique()}
    purchaseDict = {}#Format of dict --- Key = Timestamp, Value = [Stock,Row, PurchaseQTY, Price] ---- Row refers to the row of dataframe where stock is purchased
    salesDict = {} #Format of dict --- Key = Timestamp, Value = [Stock,Row, SellQTY, Price, Profit] --- to determine which exact stock is sold, use FIFO logic
    for index, row in data.iterrows():
        strategy(startCash, currentCash, row, stockQTY)

    for stock in data["symbol"].unique():
        lastRow = data.loc[data["symbol"] == stock].tail(1).iloc[0] #note to future: .iloc[0] converts one-row DF into a pd series
        qtyLeft = stockQTY.get(stock)
        sellStock(lastRow, qtyLeft, lastRow["close"])

    tradeAnalyser(data, startCash, purchaseDict, salesDict, currentCash, stockQTY)
    
    return purchaseDict, salesDict, currentCash, stockQTY



a,b,c,d = engineRun(data, 50000)

totalPnL = 0
for key, value in b.items():
    totalPnL += value[4]
    
for key, value in a.items():
    a[key] = value[:1] + value[2:]
for key, value in b.items():
    b[key] = value[:1] + value[2:]    

    

print("Purchases:\n",pd.DataFrame(a).transpose(),"\n\nSales:\n",pd.DataFrame(b).transpose(),"\nCash Remaining:   ",c,"\n\nEnd Portfolio:  ",d,"\nTotal Profit: ",totalPnL)

#Limitations:
#Algorithm is only allowed to conduct ONE SET of buy/sell action at most per candle
