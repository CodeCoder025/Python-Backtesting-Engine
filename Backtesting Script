
  import os
from alpaca.data import StockHistoricalDataClient
from alpaca.data.requests import StockBarsRequest
from alpaca.data.timeframe import TimeFrame
from datetime import datetime
import pandas as pd


#Notes:
"""Algorithm is allowed to purchase/sell stock at any price between the range of high and low. However, it cannot make this decision based on price information, nor can it make a sale AND a purchase in the same data row (ie the same minute).
    This means that the algorithm is not allowed to "know" the high and low prices, thus can only make decisions in a "hit-or-miss" manner. E.g. algorithm cannot choose to buy where price = row["Low"], but can make a decision like buy where price = 98%(Open)."""
#For future use --- row.name returns index of row
#Next step for algorithm is to have it do simple trade analysis, as well as tell the user how much more(or less) they would have made if x extra money were put into the trading account when it holds positions till out of cash
#FIFO profit vs average-based profit?

apiKey = os.getenv("AlpacaKey")
apiSecret = os.getenv("AlpacaSecret")
stock_client = StockHistoricalDataClient(apiKey, apiSecret)

def getData(stock, startDateTime, endDateTime,interval=TimeFrame.Minute):
    dataParams = StockBarsRequest(symbol_or_symbols=stock,
                                            timeframe=interval, 
                                            start=startDateTime,
                                              end=endDateTime)
    barsData = stock_client.get_stock_bars(dataParams) #For some reason the Alpaca Documentation is slightly weird i cant directly pluck the parameters into the .get_stock_bars function, it only accepts one argument
    return barsData.df.reset_index()

startDate =  datetime(2023,1,4)
endDate = datetime(2023,1,5)
timePeriod = (endDate-startDate).days*390 #390 trading minutes per trading day
data = getData(["AAPL","NVDA"], startDate, endDate)
def buyStock(row, qty, price): #Note: dont update trade og dictionary using merely timestamp as key because if diff types of stocks purchased at sqame time then new value will override
    global purchaseDict, currentCash, buyCount, stockQTY, buyStockCalled, sellStockCalled
    if sellStockCalled == False:
        if qty*price > currentCash:
            qty = int(currentCash/price) #Buys as many stocks as possible if full order cannot be fufilled
        if qty != 0:
            key = "%s%s"%(row["symbol"],row["timestamp"])
            buyStockCalled = True
            purchaseDict[key] = [row["symbol"], row, qty, price]
            currentCash -= qty*price
            buyCount +=1
            stockQTY[row["symbol"]] = stockQTY.get(row["symbol"],0) + qty
        else:
            pass

def calculateFIFOProfit(purchaseDict, salesDict, row, qty, sell_price):
    global W,L, BE
    symbol = row["symbol"]
    purchases = []
    for key, value in sorted(purchaseDict.items()):
            if value[0] == symbol:
                purchases.append({
                    'timestamp': key,
                    'qty': value[2],
                    'price': value[3]
                })
    
    total_sold_before = 0
    for key, value in salesDict.items():
        if value[0] == symbol:
            total_sold_before += value[2]

    shares_to_cost = qty  # How many shares to sell in this round of sale
    fifo_cost = 0
    shares_processed = 0
    
    for purchase in purchases:
        if shares_to_cost <= 0:
            break
            
        purchase_qty = purchase['qty']
        purchase_price = purchase['price']
        
        if shares_processed + purchase_qty <= total_sold_before:
            shares_processed += purchase_qty
            continue
        
        already_used = max(0, total_sold_before - shares_processed)
        available_shares = purchase_qty - already_used
        shares_to_use = min(available_shares, shares_to_cost)
        
        fifo_cost += shares_to_use * purchase_price
        shares_to_cost -= shares_to_use
        shares_processed += purchase_qty
        if purchase_price > sell_price:
            for i in range(0, shares_to_use):
                L.append(symbol)
        elif sell_price > purchase_price:
            for i in range(0, shares_to_use):
                W.append(symbol)
        else:
            for i in range(0, shares_to_use):
                BE.append(symbol) #gotta use append structure so that can track which stock wins, instead of just using a counter to see how many stocks win
    
    profit = (qty * sell_price) - fifo_cost
    
    return profit

def sellStock(row, qty, price):
    global purchaseDict, salesDict, currentCash, sellCount, stockQTY, sellStockCalled, buyStockCalled #buystockcalled and sellstockcalled prevents model from buying and selling stock at the same candle
    if buyStockCalled == False:
        if stockQTY.get(row["symbol"].iloc[0]) < qty:
            qty = stockQTY.get(row["symbol"])
        if qty != 0:
            key = "%s%s"%(row["symbol"],row["timestamp"])
            sellStockCalled = True
            profit = calculateFIFOProfit(purchaseDict, salesDict, row, qty, price)
            currentCash += qty*price
            sellCount += 1
            salesDict[row["timestamp"]] = [row["symbol"], row, qty, price, profit]
            stockQTY[row["symbol"]] = stockQTY.get(row["symbol"]) - qty

def calculateAvgPrc(purchaseDict):
    stocksList = sorted(data["symbol"].unique())
    avgPriceDict = {}
    reversedDict = dict(reversed(list(purchaseDict.items())))
    for stock in stocksList:
        totalCost = 0
        stockCount = stockQTY.get(stock)
        for key, value in reversedDict.items():
            if value[0] != stock:
                continue
            else:
                if stockCount > value[2]:
                    totalCost += value[3]*value[2]
                    stockCount -= value[2]
                else:
                    totalCost += value[3]*stockCount
                    stockCount = 0
                    break
        try:
            avgCost = totalCost/stockQTY.get(stock)
        except:
            avgCost = 0
        avgPriceDict[stock] = avgCost
    return avgPriceDict
                    
    
def strategy(startCash, currentCash, dataRow, currentPositions):
   
    global stockQTY, buyStockCalled, sellStockCalled
    #Simplified Strat:
    currentStock = dataRow["symbol"]
    if stockQTY.get(currentStock) == 0:
        buyStock(dataRow, 5, dataRow["open"])
                 

def tradeAnalyser(purchaseDict, salesDict, currentCash, stockQTY): #For simplicity this will be FIFO-based when calculating profits, etc. Come up with an average-based one afterwards
    for stock in data["symbols"].unique():
        salesFrequency = sum(1 for key, value in salesDict.items() if value[0] == stock)/timePeriod
        purchaseFrequency = sum(1 for key, value in purchaseDict.items() if value[0] == stock)/timePeriod 
        winRate_sales = (len([value for key, value in salesDict.items() if value[4] > 0 and value[0] == stock])/len(salesDict))*100
        winRate_perStock = (W.count(stock)/(W.count(stock)+L.count(stock)+BE.count(stock)))*100
    
                
def engineRun(data, startCash = 100000):
    global purchaseDict, salesDict, currentCash, buyCount, sellCount, winningTradeCount, stockQTY, buyStockCalled, sellStockCalled,W, L, BE
    currentCash = startCash
    W = []
    L = []
    BE = []
    buyCount = 0
    sellCount = 0
    winningTradeCount = 0
    stockQTY = {stock: 0 for stock in data["symbol"].unique()}
    purchaseDict = {}#Format of dict --- Key = Timestamp, Value = [Stock,Row, PurchaseQTY, Price] ---- Row refers to the row of dataframe where stock is purchased
    salesDict = {} #Format of dict --- Key = Timestamp, Value = [Stock,Row, SellQTY, Price, Profit] --- to determine which exact stock is sold, use FIFO logic
    buyStockCalled = False
    sellStockCalled = False
    for index, row in data.iterrows():
        strategy(startCash, currentCash, row, stockQTY)
        buyStockCalled = False
        sellStockCalled = False
    #tradeAnalyser()

    for stock in data["symbol"].unique():
        lastRow = data.loc[data["symbol"] == stock].tail(1)
        qtyLeft = stockQTY.get(stock)
        sellStock(lastRow, qtyLeft, lastRow["close"])
    
    return purchaseDict, salesDict, currentCash, stockQTY



a,b,c,d = engineRun(data, 50000)

totalPnL = 0
for key, value in b.items():
    totalPnL += value[4]
    
for key, value in a.items():
    a[key] = value[:1] + value[2:]
for key, value in b.items():
    b[key] = value[:1] + value[2:]    

    

print("Purchases:\n",pd.DataFrame(a).transpose(),"\n\nSales:\n",pd.DataFrame(b).transpose(),"\nCash Remaining:   ",c,"\n\nEnd Portfolio:  ",d,"\nTotal Profit: ",totalPnL)
#The logic behind this backtester can go two ways --- either have a static salesDict and purchaseDict where key-value pairs only get added, or have purchaseDict and salesDict to by dynamic to show current positions and total current sales
#Ill try the second one for now. Logic --- strategy calls buyStock/sellStock function, which changes sales/purchase dict.
#Yet to do:
#1) Post-Trade Statistics (e.g. total P/L? Number of Trades? Number of winning trades [this can be computed based on FIFO or Average-Based]?)
